{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Corpus Base Docs","text":"<pre><code>flowchart TD\npax(corpus-pax)--github api---&gt;sc\nsubgraph /corpus\n  1(justices)\n  2(decisions/sc)\n  3(decisions/legacy)\nend\nsubgraph local\n  1--github api---sc\n  2--local copy of corpus---sc\n  3--local copy of corpus---sc\n  sc(corpus-base)--run setup_base---&gt;db[(sqlite.db)]\nend</code></pre>"},{"location":"#concept","title":"Concept","text":"<p>In tandem with corpus-pax, <code>corpus-base</code> creates sqlpyd tables related to decisions of the Philippine Supreme Court, thereby adding the following:</p> <ol> <li>Justices</li> <li>Decisions</li> <li>Citations</li> <li>Votelines</li> <li>Titletags</li> <li>Opinions</li> <li>Segments</li> </ol>"},{"location":"#run","title":"Run","text":"Python<pre><code>&gt;&gt;&gt; from corpus_pax import setup_pax_base\n&gt;&gt;&gt; db_name =  # assume target db to be created/recreated is in the present working directory\n&gt;&gt;&gt; setup_pax_base('test.db') # takes ~20 to 30 minutes to create/recreate in working dir\n</code></pre>"},{"location":"#caveats","title":"Caveats","text":""},{"location":"#flow","title":"Flow","text":"<ol> <li>Unlike <code>corpus-pax</code> which operates over API calls, <code>corpus-base</code> operates locally.</li> <li>It implies parsing through a locally downloaded repository <code>corpus</code> to populate tables.</li> <li>Opinions are limited. Save for 1 or 2 sample situations, the present <code>corpus</code> only includes the Ponencia.</li> </ol>"},{"location":"#data","title":"Data","text":"<p>The path location of the downloaded <code>corpus</code> repository is hard-coded since this package is intended to be run locally.</p> <p>Instructions for downloading and updating the repository are discussed elsewhere.</p> <p>Now toying with the idea of placing the entire <code>corpus</code> in a bucket like AWS S3 or Cloudflare R2. So that all access can be cloud-based.</p>"},{"location":"#prerequisites","title":"Prerequisites","text":""},{"location":"#repositories","title":"Repositories","text":"<p>Different repositories involved:</p> repository status type purpose lawsql-articles private data source used by corpus-pax; yaml-formatted member and org files corpus-entities private data source used by corpus-pax; markdown-styled articles with frontmatter corpus private data source used by corpus-base corpus-pax public sqlite i/o functions to create pax-related tables corpus-base public sqlite i/o functions to create sc-related tables"},{"location":"#env","title":".env","text":"<p>Create an .env file to create/populate the database. See <code>sample .env</code> highlighting the following variables:</p> <ol> <li>Cloudflare <code>CF_ACCT</code></li> <li>Cloudflare <code>CF_TOKEN</code></li> <li>Github <code>GH_TOKEN</code></li> <li><code>DB_FILE</code> (sqlite)</li> </ol> <p>Note the workflow (main.yml) where the secrets are included for Github actions. Ensure these are set in the repository's <code>&lt;url-to-repo&gt;/settings/secrets/actions</code>, making the proper replacements when the tokens for Cloudflare and Github expire.</p>"},{"location":"#helper-function-to-do-things-incrementally","title":"Helper function to do things incrementally","text":"Python<pre><code>&gt;&gt;&gt; from corpus_base import init_sc_cases\n&gt;&gt;&gt; init_sc_cases(c, test_only=10)\n</code></pre> <p>Since there are thousands of cases, can limit the number of downloads via the <code>test_only</code> function attribute.</p>"},{"location":"justice/","title":"Justice","text":""},{"location":"justice/#corpus_base.justice-classes","title":"Classes","text":""},{"location":"justice/#corpus_base.justice.Justice","title":"<code>Justice</code>","text":"<p>         Bases: <code>Bio</code></p> Source code in <code>corpus_base/justice.py</code> Python<pre><code>class Justice(Bio):\n__prefix__ = \"sc\"\n__tablename__ = \"justices\"\n__indexes__ = [\n[\"last_name\", \"alias\", \"start_term\", \"inactive_date\"],\n[\"start_term\", \"inactive_date\"],\n[\"last_name\", \"alias\"],\n]\nid: int = Field(\n...,\ntitle=\"Justice ID Identifier\",\ndescription=(\n\"Starting from 1, the integer represents the order of appointment\"\n\" to the Supreme Court.\"\n),\nge=1,\nlt=1000,\ncol=int,\n)\nalias: str | None = Field(\nNone,\ntitle=\"Alias\",\ndescription=(\n\"Means of matching ponente and voting strings to the justice id.\"\n),\ncol=str,\nindex=True,\n)\nstart_term: datetime.date | None = Field(\nNone,\ntitle=\"Start Term\",\ndescription=\"Date of appointment.\",\ncol=datetime.date,\nindex=True,\n)\nend_term: datetime.date | None = Field(\nNone,\ntitle=\"End Term\",\ndescription=\"Date of termination.\",\ncol=datetime.date,\nindex=True,\n)\nchief_date: datetime.date | None = Field(\nNone,\ntitle=\"Date Appointed As Chief Justice\",\ndescription=(\n\"When appointed, the extension title of the justice changes from\"\n\" 'J.' to 'C.J'. for cases that are decided after the date of\"\n\" appointment but before the date of retirement.\"\n),\ncol=datetime.date,\nindex=True,\n)\nbirth_date: datetime.date | None = Field(\nNone,\ntitle=\"Date of Birth\",\ndescription=(\n\"The Birth Date is used to determine the retirement age of the\"\n\" justice. Under the 1987 constitution, this is\"\nf\" {MAX_JUSTICE_AGE}. There are missing dates: see Jose Generoso\"\n\" 41, Grant Trent 14, Fisher 19, Moir 20.\"\n),\ncol=datetime.date,\nindex=True,\n)\nretire_date: datetime.date | None = Field(\nNone,\ntitle=\"Mandatory Retirement Date\",\ndescription=(\n\"Based on the Birth Date, if it exists, it is the maximum term of\"\n\" service allowed by law.\"\n),\ncol=datetime.date,\nindex=True,\n)\ninactive_date: datetime.date | None = Field(\nNone,\ntitle=\"Date\",\ndescription=(\n\"Which date is earliest inactive date of the Justice, the retire\"\n\" date is set automatically but it is not guaranteed to to be the\"\n\" actual inactive date. So the inactive date is either that\"\n\" specified in the `end_term` or the `retire_date`, whichever is\"\n\" earlier.\"\n),\ncol=datetime.date,\nindex=True,\n)\n@validator(\"retire_date\")\ndef retire_date_70_years(cls, v, values):\nif v and values[\"birth_date\"]:\nif values[\"birth_date\"] + rd(years=MAX_JUSTICE_AGE) != v:\nraise ValueError(\"Must be 70 years from birth date.\")\nreturn v\nclass Config:\nuse_enum_values = True\n@classmethod\ndef from_data(cls, data: dict):\ndef extract_date(text: str | None) -&gt; datetime.date | None:\nreturn parse(text).date() if text else None\nbio = Bio.from_dict(data)\n# Not all have aliases; default needed\nalias = data.pop(\"Alias\", None)\nif not alias:\nif bio.last_name and bio.suffix:\nalias = f\"{bio.last_name} {bio.suffix}\".lower()\nretire_date = None\nif dob := extract_date(data.pop(\"Born\")):\nretire_date = dob + rd(years=MAX_JUSTICE_AGE)\n# Assume that the retire_date is latest possible date of inactivity but if end_date is present, use this instead\ninactive_date = retire_date\nif end_date := extract_date(data.pop(\"End of term\")):\ninactive_date = end_date or retire_date\nreturn cls(\n**bio.dict(exclude_none=True),\nid=data.pop(\"#\"),\nalias=alias,\nbirth_date=dob,\nstart_term=extract_date(data.pop(\"Start of term\")),\nend_term=end_date,\nchief_date=extract_date(data.pop(\"Appointed chief\")),\nretire_date=retire_date,\ninactive_date=inactive_date,\n)\n@classmethod\ndef validate_from_api(cls) -&gt; Iterator[\"Justice\"]:\nreturn (cls.from_data(i) for i in get_justices_from_api())\n@classmethod\ndef extract_as_list(cls) -&gt; list[dict]:\nreturn [i.dict(exclude_none=True) for i in cls.validate_from_api()]\n@classmethod\ndef set_local_from_api(cls, local: Path = JUSTICE_LOCAL) -&gt; Path:\n\"\"\"Create a local .yaml file containing the list of validated Justices.\n        \"\"\"\nif local.exists():\nreturn local\nwith open(local, \"w\") as writefile:\nyaml.safe_dump(\ndata=cls.extract_as_list(),\nstream=writefile,\nsort_keys=False,\ndefault_flow_style=False,\n)\nreturn local\n@classmethod\ndef init_justices_tbl(cls, c: Connection, p: Path = JUSTICE_LOCAL):\n\"\"\"Add a table containing names and ids of justices; alter the original decision's table for it to include a justice id.\n        \"\"\"\nreturn c.add_records(Justice, yaml.safe_load(p.read_bytes()))\n@classmethod\ndef get_active_on_date(cls, c: Connection, target_date: str) -&gt; list[dict]:\n\"\"\"Get list of justices that have been appointed before the `target date` and have not yet become inactive.\n        \"\"\"\ntry:\nvalid_date = parse(target_date).date().isoformat()\nexcept Exception:\nraise Exception(f\"Need {target_date=}\")\nreturn list(\nc.table(cls).rows_where(\n\"inactive_date &gt; :date and :date &gt; start_term\",\n{\"date\": valid_date},\nselect=(\n\"id, lower(last_name) surname, alias, start_term,\"\n\" inactive_date, chief_date\"\n),\norder_by=\"start_term desc\",\n)\n)\n@classmethod\ndef get_justice_on_date(\ncls, c: Connection, target_date: str, cleaned_name: str\n) -&gt; dict | None:\n\"\"\"Based on `get_active_on_date()`, match the cleaned_name to either the alias of the justice or the justice's last name; on match, determine whether the designation should be 'C.J.' or 'J.'\n        \"\"\"\ncandidate_options = cls.get_active_on_date(c, target_date)\nopts = []\nfor candidate in candidate_options:\nif candidate[\"alias\"] and candidate[\"alias\"] == cleaned_name:\nopts.append(candidate)\ncontinue\nelif candidate[\"surname\"] == cleaned_name:\nopts.append(candidate)\ncontinue\nif opts:\nif len(opts) == 1:\nres = opts[0]\nres.pop(\"alias\")\nres[\"surname\"] = res[\"surname\"].title()\nres[\"designation\"] = \"J.\"\ntarget = parse(target_date).date()\nif chief_date := res.get(\"chief_date\"):\ns = parse(chief_date).date()\ne = parse(res[\"inactive_date\"]).date()\nif s &lt; target &lt; e:\nres[\"designation\"] = \"C.J.\"\nreturn res\nelse:\nmsg = f\"Many {opts=} for {cleaned_name=} on {target_date=}\"\nlogger.warning(msg)\nreturn None\n@classmethod\ndef view_chiefs(cls, c: Connection) -&gt; list[dict]:\n\"\"\"Get general information of the chief justices and their dates of appointment.\n        \"\"\"\nview = CHIEF_DATES_VIEW\nif view in c.db.view_names():\nreturn list(c.db[view].rows)\nc.db.create_view(\nview,\nsql=sc_jinja_env.get_template(\"chief_dates.sql\").render(\njustice_table=Justice.__tablename__\n),\n)\nreturn list(c.db[view].rows)\n</code></pre>"},{"location":"justice/#corpus_base.justice.Justice-functions","title":"Functions","text":""},{"location":"justice/#corpus_base.justice.Justice.get_active_on_date","title":"<code>get_active_on_date(c, target_date)</code>  <code>classmethod</code>","text":"<p>Get list of justices that have been appointed before the <code>target date</code> and have not yet become inactive.</p> Source code in <code>corpus_base/justice.py</code> Python<pre><code>@classmethod\ndef get_active_on_date(cls, c: Connection, target_date: str) -&gt; list[dict]:\n\"\"\"Get list of justices that have been appointed before the `target date` and have not yet become inactive.\n    \"\"\"\ntry:\nvalid_date = parse(target_date).date().isoformat()\nexcept Exception:\nraise Exception(f\"Need {target_date=}\")\nreturn list(\nc.table(cls).rows_where(\n\"inactive_date &gt; :date and :date &gt; start_term\",\n{\"date\": valid_date},\nselect=(\n\"id, lower(last_name) surname, alias, start_term,\"\n\" inactive_date, chief_date\"\n),\norder_by=\"start_term desc\",\n)\n)\n</code></pre>"},{"location":"justice/#corpus_base.justice.Justice.get_justice_on_date","title":"<code>get_justice_on_date(c, target_date, cleaned_name)</code>  <code>classmethod</code>","text":"<p>Based on <code>get_active_on_date()</code>, match the cleaned_name to either the alias of the justice or the justice's last name; on match, determine whether the designation should be 'C.J.' or 'J.'</p> Source code in <code>corpus_base/justice.py</code> Python<pre><code>@classmethod\ndef get_justice_on_date(\ncls, c: Connection, target_date: str, cleaned_name: str\n) -&gt; dict | None:\n\"\"\"Based on `get_active_on_date()`, match the cleaned_name to either the alias of the justice or the justice's last name; on match, determine whether the designation should be 'C.J.' or 'J.'\n    \"\"\"\ncandidate_options = cls.get_active_on_date(c, target_date)\nopts = []\nfor candidate in candidate_options:\nif candidate[\"alias\"] and candidate[\"alias\"] == cleaned_name:\nopts.append(candidate)\ncontinue\nelif candidate[\"surname\"] == cleaned_name:\nopts.append(candidate)\ncontinue\nif opts:\nif len(opts) == 1:\nres = opts[0]\nres.pop(\"alias\")\nres[\"surname\"] = res[\"surname\"].title()\nres[\"designation\"] = \"J.\"\ntarget = parse(target_date).date()\nif chief_date := res.get(\"chief_date\"):\ns = parse(chief_date).date()\ne = parse(res[\"inactive_date\"]).date()\nif s &lt; target &lt; e:\nres[\"designation\"] = \"C.J.\"\nreturn res\nelse:\nmsg = f\"Many {opts=} for {cleaned_name=} on {target_date=}\"\nlogger.warning(msg)\nreturn None\n</code></pre>"},{"location":"justice/#corpus_base.justice.Justice.init_justices_tbl","title":"<code>init_justices_tbl(c, p=JUSTICE_LOCAL)</code>  <code>classmethod</code>","text":"<p>Add a table containing names and ids of justices; alter the original decision's table for it to include a justice id.</p> Source code in <code>corpus_base/justice.py</code> Python<pre><code>@classmethod\ndef init_justices_tbl(cls, c: Connection, p: Path = JUSTICE_LOCAL):\n\"\"\"Add a table containing names and ids of justices; alter the original decision's table for it to include a justice id.\n    \"\"\"\nreturn c.add_records(Justice, yaml.safe_load(p.read_bytes()))\n</code></pre>"},{"location":"justice/#corpus_base.justice.Justice.set_local_from_api","title":"<code>set_local_from_api(local=JUSTICE_LOCAL)</code>  <code>classmethod</code>","text":"<p>Create a local .yaml file containing the list of validated Justices.</p> Source code in <code>corpus_base/justice.py</code> Python<pre><code>@classmethod\ndef set_local_from_api(cls, local: Path = JUSTICE_LOCAL) -&gt; Path:\n\"\"\"Create a local .yaml file containing the list of validated Justices.\n    \"\"\"\nif local.exists():\nreturn local\nwith open(local, \"w\") as writefile:\nyaml.safe_dump(\ndata=cls.extract_as_list(),\nstream=writefile,\nsort_keys=False,\ndefault_flow_style=False,\n)\nreturn local\n</code></pre>"},{"location":"justice/#corpus_base.justice.Justice.view_chiefs","title":"<code>view_chiefs(c)</code>  <code>classmethod</code>","text":"<p>Get general information of the chief justices and their dates of appointment.</p> Source code in <code>corpus_base/justice.py</code> Python<pre><code>@classmethod\ndef view_chiefs(cls, c: Connection) -&gt; list[dict]:\n\"\"\"Get general information of the chief justices and their dates of appointment.\n    \"\"\"\nview = CHIEF_DATES_VIEW\nif view in c.db.view_names():\nreturn list(c.db[view].rows)\nc.db.create_view(\nview,\nsql=sc_jinja_env.get_template(\"chief_dates.sql\").render(\njustice_table=Justice.__tablename__\n),\n)\nreturn list(c.db[view].rows)\n</code></pre>"},{"location":"justice/#insert-records","title":"Insert records","text":"<p>Can add all pydantic validated records from the local copy of justices to the database.</p> Python<pre><code>&gt;&gt;&gt; from corpus_base import Justice\n&gt;&gt;&gt; Justice.init_justices_tbl(c) # c = instantiated Connection\n&lt;Table justices_tbl (first_name, last_name, suffix, full_name, gender, id, alias, start_term, end_term, chief_date, birth_date, retire_date, inactive_date)&gt;\n</code></pre>"},{"location":"justice/#clean-raw-ponente-string","title":"Clean raw ponente string","text":"<p>Each <code>ponente</code> name stored in <code>decisions_tbl</code> of the database has been made uniform, e.g.:</p> Python<pre><code>&gt;&gt;&gt; from corpus_base import RawPonente\n&gt;&gt;&gt; RawPonente.clean(\"REYES , J.B.L, Acting C.J.\") # sample name 1\n\"reyes, j.b.l.\"\n&gt;&gt;&gt; RawPonente.clean(\"REYES, J, B. L. J.\") # sample name 2\n\"reyes, j.b.l.\"\n</code></pre> <p>We can see  most common names in the <code>ponente</code> field and the covered dates, e.g. from 1954 to 1972 (dates found in the decisions), there have been 1053 decisions marked with <code>jbl</code> (as cleaned):</p> Python<pre><code>&gt;&gt;&gt; from corpus_base.helpers import most_popular\n&gt;&gt;&gt; [i for i in most_popular(c, db)] # excluding per curiams and unidentified cases\n[\n('1994-07-04', '2017-08-09', 'mendoza', 1297), # note multiple personalities named mendoza, hence long range from 1994-2017\n('1921-10-22', '1992-07-03', 'paras', 1287), # note multiple personalities named paras, hence long range from 1921-1992\n('2009-03-17', '2021-03-24', 'peralta', 1243),\n('1998-06-18', '2009-10-30', 'quisumbing', 1187),\n('1999-06-28', '2011-06-02', 'ynares-santiago', 1184),\n('1956-04-28', '2008-04-04', 'panganiban', 1102),\n('1936-11-19', '2009-11-05', 'concepcion', 1058), # note multiple personalities named concepcion, hence long range from 1936-2009\n('1954-07-30', '1972-08-18', 'reyes, j.b.l.', 1053),\n('1903-11-21', '1932-03-31', 'johnson', 1043),\n('1950-11-16', '1999-05-23', 'bautista angelo', 1028), # this looks like bad data\n('2001-11-20', '2019-10-15', 'carpio', 1011),\n...\n]\n</code></pre>"},{"location":"justice/#isolate-active-justices-on-date","title":"Isolate active justices on date","text":"<p>When selecting a ponente or voting members, create a candidate list of justices based on date:</p> Python<pre><code>&gt;&gt;&gt; from corpus_base import Justice\n&gt;&gt;&gt; Justice.get_active_on_date(c, 'Dec. 1, 1995') # target date\n[\n{\n'id': 137,\n'surname': 'panganiban',\n'alias': None,\n'start_term': '1995-10-05', # since start date is greater than target date, record is included\n'inactive_date': '2006-12-06',\n'chief_date': '2005-12-20'\n},\n{\n'id': 136,\n'surname': 'hermosisima',\n'alias': 'hermosisima jr.',\n'start_term': '1995-01-10',\n'inactive_date': '1997-10-18',\n'chief_date': None\n},\n]\n</code></pre>"},{"location":"justice/#designation-as-chief-or-associate","title":"Designation as chief or associate","text":"<p>Since we already have candidates, we can cleaning desired option to get the <code>id</code> and <code>designation</code>:</p> Python<pre><code>&gt;&gt;&gt; from corpus_base import RawPonente\n&gt;&gt;&gt; RawPonente.clean('Panganiban, Acting Cj')\n'panganiban'\n&gt;&gt;&gt; Justice.get_justice_on_date(c, '2005-09-08', 'panganiban')\n{\n'id': 137,\n'surname': 'Panganiban',\n'start_term': '1995-10-05',\n'inactive_date': '2006-12-06',\n'chief_date': '2005-12-20',\n'designation': 'J.' # note variance\n}\n</code></pre> <p>Note that the raw information above contains 'Acting Cj' and thus the designation is only 'J.'</p> <p>At present we only track 'C.J.' and 'J.' titles.</p> <p>With a different date, we can get the 'C.J.' designation.:</p> Python<pre><code>&gt;&gt;&gt; Justice.get_justice_on_date('2006-03-30', 'panganiban')\n{\n'id': 137,\n'surname': 'Panganiban',\n'start_term': '1995-10-05',\n'inactive_date': '2006-12-06',\n'chief_date': '2005-12-20',\n'designation': 'C.J.' # corrected\n}\n</code></pre>"},{"location":"justice/#view-chief-justice-dates","title":"View chief justice dates","text":"Python<pre><code>&gt;&gt;&gt; from corpus_base import Justice\n&gt;&gt;&gt; Justice.view_chiefs(c)\n[\n{\n'id': 178,\n'last_name': 'Gesmundo',\n'chief_date': '2021-04-05',\n'max_end_chief_date': None,\n'actual_inactive_as_chief': None,\n'years_as_chief': None\n},\n{\n'id': 162,\n'last_name': 'Peralta',\n'chief_date': '2019-10-23',\n'max_end_chief_date': '2021-04-04',\n'actual_inactive_as_chief': '2021-03-27',\n'years_as_chief': 2\n},\n{\n'id': 163,\n'last_name': 'Bersamin',\n'chief_date': '2018-11-26',\n'max_end_chief_date': '2019-10-22',\n'actual_inactive_as_chief': '2019-10-18',\n'years_as_chief': 1\n},\n{\n'id': 160,\n'last_name': 'Leonardo-De Castro',\n'chief_date': '2018-08-28',\n'max_end_chief_date': '2018-11-25',\n'actual_inactive_as_chief': '2018-10-08',\n'years_as_chief': 0\n}...\n]\n</code></pre>"},{"location":"reference/","title":"Reference","text":""},{"location":"reference/#decision","title":"Decision","text":"<p>         Bases: <code>TableConfig</code></p> Source code in <code>corpus_base/decision.py</code> Python<pre><code>class DecisionRow(TableConfig):\n__prefix__ = \"sc\"\n__tablename__ = \"decisions\"\n__indexes__ = [\n[\"date\", \"justice_id\", \"raw_ponente\", \"per_curiam\"],\n[\"source\", \"origin\", \"date\"],\n[\"source\", \"origin\"],\n[\"category\", \"composition\"],\n[\"id\", \"justice_id\"],\n[\"per_curiam\", \"raw_ponente\"],\n]\nid: str = Field(col=str)\ncreated: float = Field(col=float)\nmodified: float = Field(col=float)\norigin: str = Field(col=str, index=True)\nsource: DecisionSource = Field(col=str, index=True)\ncitation: Citation = Field(exclude=True)\nemails: list[str] = Field(col=str)\ntitle: str = Field(col=str, index=True, fts=True)\ndescription: str = Field(col=str, index=True, fts=True)\ndate: datetime.date = Field(col=datetime.date, index=True)\nraw_ponente: str | None = Field(\nNone,\ntitle=\"Ponente\",\ndescription=(\n\"After going through a cleaning process, this should be in\"\n\" lowercase and be suitable for matching a justice id.\"\n),\ncol=str,\nindex=True,\n)\njustice_id: int | None = Field(\nNone,\ntitle=\"Justice ID\",\ndescription=(\n\"Using the raw_ponente, determine the appropriate justice_id using\"\n\" the `update_justice_ids.sql` template.\"\n),\ncol=int,\nindex=True,\n)\nper_curiam: bool = Field(\nFalse,\ntitle=\"Is Per Curiam\",\ndescription=\"If true, decision was penned anonymously.\",\ncol=bool,\nindex=True,\n)\ncomposition: CourtComposition = Field(None, col=str, index=True)\ncategory: DecisionCategory = Field(None, col=str, index=True)\nfallo: str | None = Field(None, col=str, index=True, fts=True)\nvoting: str | None = Field(None, col=str, index=True, fts=True)\n@root_validator()\ndef citation_date_is_object_date(cls, values):\ncite, date = values.get(\"citation\"), values.get(\"date\")\nif cite.docket_date:\nif cite.docket_date != date:\nmsg = f\"Inconsistent {cite.docket_date=} vs. {date=};\"\nlogger.error(msg)\nraise ValueError(msg)\nreturn values\n@root_validator()\ndef legacy_upto_1995(cls, values):\nsource, date = values.get(\"source\"), values.get(\"date\")\nif source == \"legacy\":\nif date and date &gt; datetime.date(year=1995, month=12, day=31):\nmsg = \"Improper parsing of legacy decision\"\nlogger.error(msg)\nraise ValueError(msg)\nreturn values\nclass Config:\nuse_enum_values = True\n@classmethod\ndef from_path(cls, c: Connection, p: Path):\n\"\"\"Requires path be structured, viz.:\n        ```yaml\n        - /decisions\n            - /source e.g. sc / legacy # where the file was scraped from\n                - /folder_name, e.g. 12341 # the original id when scraped\n                    - /details.yaml #the file containing the metadata that is `p`\n        ```\n        \"\"\"\nf = p.parent / \"fallo.html\"\ndata = yaml.safe_load(p.read_text())\npon = RawPonente.extract(data.get(\"ponente\"))\ncitation = Citation.extract_citation_from_data(data)\nid = cls.get_id_from_citation(\nfolder_name=p.parent.name,\nsource=p.parent.parent.stem,\ncitation=citation,\n)\nreturn cls(\nid=id,\norigin=p.parent.name,\nsource=DecisionSource(p.parent.parent.stem),\ncreated=p.stat().st_ctime,\nmodified=p.stat().st_mtime,\ntitle=data.get(\"case_title\"),\ndescription=citation.display,\ndate=data.get(\"date_prom\"),\ncomposition=CourtComposition._setter(data.get(\"composition\")),\ncategory=DecisionCategory._setter(data.get(\"category\")),\nfallo=markdownify(f.read_text()) if f.exists() else None,\nvoting=voteline_clean(data.get(\"voting\")),\nraw_ponente=pon.writer if pon else None,\njustice_id=cls.get_justice_id(c, pon, data.get(\"date_prom\"), p),\nper_curiam=pon.per_curiam if pon else False,\ncitation=citation,\nemails=data.get(\"emails\", [\"bot@lawsql.com\"]),\n)\n@classmethod\ndef get_justice_id(\ncls,\nc: Connection,\nponente: RawPonente | None,\nraw_date: str,\npath: Path,\n) -&gt; int | None:\nif not ponente or not raw_date:\nreturn None\nif not ponente.writer:\nreturn None\ntry:\nconv_date = parse(raw_date).date().isoformat()\nexcept Exception as e:\nlogger.error(f\"Bad {raw_date=}; {e=} {path=}\")\nreturn None\ncandidates = c.db.execute_returning_dicts(\nsql=sc_jinja_env.get_template(\"get_justice_id.sql\").render(\njustice_tbl=Justice.__tablename__,\ntarget_name=ponente.writer,\ntarget_date=conv_date,\n)\n)\nif not candidates:\nlogger.error(f\"No id: {ponente.writer=}; {conv_date=}; {path=}\")\nreturn None\nelif len(candidates) &gt; 1:\nlogger.error(f\"Multiple ids; similarity {candidates=}; {path=}\")\nreturn None\nreturn candidates[0][\"id\"]\n@classmethod\ndef get_id_from_citation(\ncls, folder_name: str, source: str, citation: Citation\n) -&gt; str:\n\"\"\"The decision id to be used as a url slug ought to be unique,\n        based on citation paramters if possible.\"\"\"\nif not citation.slug:\nlogger.debug(f\"Citation absent: {source=}; {folder_name=}\")\nreturn folder_name\nif source == \"legacy\":\nreturn citation.slug or folder_name\nelif citation.docket:\nif report := citation.scra or citation.phil:\nreturn slugify(\"-\".join([citation.docket, report]))\nreturn slugify(citation.docket)\nreturn folder_name\n@property\ndef citation_fk(self) -&gt; dict:\nreturn self.citation.dict() | {\"decision_id\": self.id}\n</code></pre>"},{"location":"reference/#corpus_base.decision.DecisionRow-functions","title":"Functions","text":""},{"location":"reference/#corpus_base.decision.DecisionRow.from_path","title":"<code>from_path(c, p)</code>  <code>classmethod</code>","text":"<p>Requires path be structured, viz.:</p> YAML<pre><code>- /decisions\n- /source e.g. sc / legacy # where the file was scraped from\n- /folder_name, e.g. 12341 # the original id when scraped\n- /details.yaml #the file containing the metadata that is `p`\n</code></pre> Source code in <code>corpus_base/decision.py</code> Python<pre><code>@classmethod\ndef from_path(cls, c: Connection, p: Path):\n\"\"\"Requires path be structured, viz.:\n    ```yaml\n    - /decisions\n        - /source e.g. sc / legacy # where the file was scraped from\n            - /folder_name, e.g. 12341 # the original id when scraped\n                - /details.yaml #the file containing the metadata that is `p`\n    ```\n    \"\"\"\nf = p.parent / \"fallo.html\"\ndata = yaml.safe_load(p.read_text())\npon = RawPonente.extract(data.get(\"ponente\"))\ncitation = Citation.extract_citation_from_data(data)\nid = cls.get_id_from_citation(\nfolder_name=p.parent.name,\nsource=p.parent.parent.stem,\ncitation=citation,\n)\nreturn cls(\nid=id,\norigin=p.parent.name,\nsource=DecisionSource(p.parent.parent.stem),\ncreated=p.stat().st_ctime,\nmodified=p.stat().st_mtime,\ntitle=data.get(\"case_title\"),\ndescription=citation.display,\ndate=data.get(\"date_prom\"),\ncomposition=CourtComposition._setter(data.get(\"composition\")),\ncategory=DecisionCategory._setter(data.get(\"category\")),\nfallo=markdownify(f.read_text()) if f.exists() else None,\nvoting=voteline_clean(data.get(\"voting\")),\nraw_ponente=pon.writer if pon else None,\njustice_id=cls.get_justice_id(c, pon, data.get(\"date_prom\"), p),\nper_curiam=pon.per_curiam if pon else False,\ncitation=citation,\nemails=data.get(\"emails\", [\"bot@lawsql.com\"]),\n)\n</code></pre>"},{"location":"reference/#corpus_base.decision.DecisionRow.get_id_from_citation","title":"<code>get_id_from_citation(folder_name, source, citation)</code>  <code>classmethod</code>","text":"<p>The decision id to be used as a url slug ought to be unique, based on citation paramters if possible.</p> Source code in <code>corpus_base/decision.py</code> Python<pre><code>@classmethod\ndef get_id_from_citation(\ncls, folder_name: str, source: str, citation: Citation\n) -&gt; str:\n\"\"\"The decision id to be used as a url slug ought to be unique,\n    based on citation paramters if possible.\"\"\"\nif not citation.slug:\nlogger.debug(f\"Citation absent: {source=}; {folder_name=}\")\nreturn folder_name\nif source == \"legacy\":\nreturn citation.slug or folder_name\nelif citation.docket:\nif report := citation.scra or citation.phil:\nreturn slugify(\"-\".join([citation.docket, report]))\nreturn slugify(citation.docket)\nreturn folder_name\n</code></pre>"},{"location":"reference/#citation","title":"Citation","text":"<p>         Bases: <code>Citation</code>, <code>TableConfig</code></p> Source code in <code>corpus_base/decision.py</code> Python<pre><code>class CitationRow(Citation, TableConfig):\n__prefix__ = \"sc\"\n__tablename__ = \"citations\"\n__indexes__ = [\n[\"id\", \"decision_id\"],\n[\"docket_category\", \"docket_serial\", \"docket_date\"],\n[\"scra\", \"phil\", \"offg\", \"docket\"],\n]\ndecision_id: str = Field(\n..., col=str, fk=(DecisionRow.__tablename__, \"id\")\n)\n</code></pre>"},{"location":"reference/#title-tag","title":"Title Tag","text":"<p>         Bases: <code>TableConfig</code></p> Source code in <code>corpus_base/decision.py</code> Python<pre><code>class TitleTagRow(TableConfig):\n__prefix__ = \"sc\"\n__tablename__ = \"titletags\"\ndecision_id: str = Field(\n..., col=str, fk=(DecisionRow.__tablename__, \"id\")\n)\ntag: str = Field(..., col=str, index=True)\n</code></pre>"},{"location":"reference/#vote-line","title":"Vote Line","text":"<p>         Bases: <code>TableConfig</code></p> Source code in <code>corpus_base/decision.py</code> Python<pre><code>class VoteLine(TableConfig):\n__prefix__ = \"sc\"\n__tablename__ = \"votelines\"\n__indexes__ = [[\"id\", \"decision_id\"]]\ndecision_id: str = Field(\n..., col=str, fk=(DecisionRow.__tablename__, \"id\")\n)\ntext: str = Field(\n...,\ntitle=\"Voteline Text\",\ndescription=(\n\"Each decision may contain a vote line, e.g. a summary of which\"\n\" justice voted for the main opinion and those who dissented, etc.\"\n),\ncol=str,\nindex=True,\n)\n</code></pre>"},{"location":"reference/#opinion","title":"Opinion","text":"<p>         Bases: <code>TableConfig</code></p> Source code in <code>corpus_base/decision.py</code> Python<pre><code>class OpinionRow(TableConfig):\n__prefix__ = \"sc\"\n__tablename__ = \"opinions\"\n__indexes__ = [\n[\"id\", \"title\"],\n[\"id\", \"justice_id\"],\n[\"id\", \"decision_id\"],\n[\"decision_id\", \"title\"],\n]\ndecision_id: str = Field(\n..., col=str, fk=(DecisionRow.__tablename__, \"id\")\n)\nid: str = Field(\n...,\ndescription=(\n\"The opinion pk is based on combining the decision_id with the\"\n\" justice_id\"\n),\ncol=str,\n)\ntitle: str | None = Field(\n...,\ndescription=(\n\"How is the opinion called, e.g. Ponencia, Concurring Opinion,\"\n\" Separate Opinion\"\n),\ncol=str,\n)\ntags: list[str] | None = Field(\nNone,\ndescription=\"e.g. main, dissenting, concurring, separate\",\n)\njustice_id: int | None = Field(\nNone,\ndescription=(\n\"The writer of the opinion; when not supplied could mean a Per\"\n\" Curiam opinion, or unable to detect the proper justice.\"\n),\ncol=int,\nindex=True,\nfk=(Justice.__tablename__, \"id\"),\n)\nremark: str | None = Field(\nNone,\ndescription=(\n\"Short description of the opinion, when available, i.e. 'I reserve\"\n\" my right, etc.', 'On leave.', etc.\"\n),\ncol=str,\nfts=True,\n)\nconcurs: list[dict] | None\ntext: str = Field(\n..., description=\"Text proper of the opinion.\", col=str, fts=True\n)\n@classmethod\ndef get_opinions(\ncls,\ncase_path: Path,\ndecision_id: str,\njustice_id: int | None = None,\n) -&gt; Iterator:\n\"\"\"Each opinion of a decision, except the ponencia, should be added separately.\n        The format of the opinion should follow the form in test_data/legacy/tanada1.\n        \"\"\"\nops = case_path / \"opinions\"\nfor op in ops.glob(\"[!ponencia]*.md\"):\nopinion = cls.extract_separate(case_path, decision_id, op)\nyield opinion\nif main := cls.extract_main(case_path, decision_id, justice_id):\nyield main\n@classmethod\ndef extract_separate(\ncls, case_path: Path, decision_id: str, opinion_path: Path\n):\ndata = frontmatter.loads(opinion_path.read_text())\nreturn cls(\nid=f\"{case_path.stem}-{opinion_path.stem}\",\ntitle=data.get(\"title\", None),\ntags=data.get(\"tags\", []),\ndecision_id=decision_id,\njustice_id=int(opinion_path.stem),\nremark=data.get(\"remark\", None),\nconcurs=data.get(\"concur\", None),\ntext=data.content,\n)\n@classmethod\ndef extract_main(\ncls, case_path: Path, decision_id: str, justice_id: int | None = None\n):\ntry:  # option: add_markdown_file(case_path, md_txt.result)\nreturn cls(\nid=f\"{case_path.stem}-main\",\ntitle=\"Ponencia\",\ntags=[\"main\"],\ndecision_id=decision_id,\njustice_id=justice_id,\nremark=None,\nconcurs=None,\ntext=DecisionHTMLConvertMarkdown(case_path).result,\n)\nexcept Exception as e:\nlogger.error(f\"Could not convert text {case_path.stem=}; see {e=}\")\nreturn None\n@property\ndef segments(self) -&gt; Iterator[dict[str, Any]]:\n\"\"\"Validate each segment and output its dict format.\"\"\"\nfrom .segment import SegmentRow\nfor extract in SegmentRow.segmentize(self.text):\nyield SegmentRow(\nid=f\"{self.id}-{extract['position']}\",\ndecision_id=self.decision_id,\nopinion_id=self.id,\n**extract,\n).dict()\n</code></pre>"},{"location":"reference/#corpus_base.decision.OpinionRow-attributes","title":"Attributes","text":""},{"location":"reference/#corpus_base.decision.OpinionRow.segments","title":"<code>segments: Iterator[dict[str, Any]]</code>  <code>property</code>","text":"<p>Validate each segment and output its dict format.</p>"},{"location":"reference/#corpus_base.decision.OpinionRow-functions","title":"Functions","text":""},{"location":"reference/#corpus_base.decision.OpinionRow.get_opinions","title":"<code>get_opinions(case_path, decision_id, justice_id=None)</code>  <code>classmethod</code>","text":"<p>Each opinion of a decision, except the ponencia, should be added separately. The format of the opinion should follow the form in test_data/legacy/tanada1.</p> Source code in <code>corpus_base/decision.py</code> Python<pre><code>@classmethod\ndef get_opinions(\ncls,\ncase_path: Path,\ndecision_id: str,\njustice_id: int | None = None,\n) -&gt; Iterator:\n\"\"\"Each opinion of a decision, except the ponencia, should be added separately.\n    The format of the opinion should follow the form in test_data/legacy/tanada1.\n    \"\"\"\nops = case_path / \"opinions\"\nfor op in ops.glob(\"[!ponencia]*.md\"):\nopinion = cls.extract_separate(case_path, decision_id, op)\nyield opinion\nif main := cls.extract_main(case_path, decision_id, justice_id):\nyield main\n</code></pre>"},{"location":"reference/#segment","title":"Segment","text":"<p>         Bases: <code>TableConfig</code></p> Source code in <code>corpus_base/segment.py</code> Python<pre><code>class SegmentRow(TableConfig):\n__prefix__ = \"sc\"\n__tablename__ = \"segments\"\n__indexes__ = [\n[\"opinion_id\", \"decision_id\"],\n]\nid: str = Field(..., col=str)\ndecision_id: str = Field(\n...,\ncol=str,\nfk=(DecisionRow.__tablename__, \"id\"),\n)\nopinion_id: str = Field(\n...,\ncol=str,\nfk=(OpinionRow.__tablename__, \"id\"),\n)\nposition: str = Field(\n...,\ntitle=\"Relative Position\",\ndescription=(\n\"The line number of the text as stripped from its markdown source.\"\n),\ncol=int,\nindex=True,\n)\nchar_count: int = Field(\n...,\ntitle=\"Character Count\",\ndescription=(\n\"The number of characters of the text makes it easier to discover\"\n\" patterns.\"\n),\ncol=int,\nindex=True,\n)\nsegment: str = Field(\n...,\ntitle=\"Body Segment\",\ndescription=(\n\"A partial text fragment of an opinion, exclusive of footnotes.\"\n),\ncol=str,\nfts=True,\n)\n@classmethod\ndef segmentize(cls, full_text: str) -&gt; Iterator[dict]:\n\"\"\"Split first by double-spaced breaks `\\\\n\\\\n` and then by\n        single spaced breaks `\\\\n` to get the position of the segment.\n        Will exclude footnotes and segments with less than 10 characters.\n        For comparison:\n        Minimum characters | Total Num. of Rows | Time to Create from Scratch\n        :--:|:--:|:--:\n        10 | ~3.2m | 30 minutes\n        Args:\n            full_text (str): The opinion to segment\n        Yields:\n            Iterator[dict]: The partial segment data fields\n        \"\"\"\nif cleaned_text := standardize(full_text):\nif subdivisions := double_spaced.split(cleaned_text):\nfor idx, text in enumerate(subdivisions):\nif lines := single_spaced.split(text):\nfor sub_idx, segment in enumerate(lines):\n# --- marks the footnote boundary\nif segment == \"---\":\nreturn\nposition = f\"{idx}-{sub_idx}\"\nchar_count = len(segment)\nif char_count &gt; 10:\nyield {\n\"position\": position,\n\"segment\": segment,\n\"char_count\": char_count,\n}\n</code></pre>"},{"location":"reference/#corpus_base.segment.SegmentRow-functions","title":"Functions","text":""},{"location":"reference/#corpus_base.segment.SegmentRow.segmentize","title":"<code>segmentize(full_text)</code>  <code>classmethod</code>","text":"<p>Split first by double-spaced breaks <code>\\n\\n</code> and then by single spaced breaks <code>\\n</code> to get the position of the segment.</p> <p>Will exclude footnotes and segments with less than 10 characters.</p> <p>For comparison:</p> Minimum characters Total Num. of Rows Time to Create from Scratch 10 ~3.2m 30 minutes <p>Parameters:</p> Name Type Description Default <code>full_text</code> <code>str</code> <p>The opinion to segment</p> required <p>Yields:</p> Type Description <code>Iterator[dict]</code> <p>Iterator[dict]: The partial segment data fields</p> Source code in <code>corpus_base/segment.py</code> Python<pre><code>@classmethod\ndef segmentize(cls, full_text: str) -&gt; Iterator[dict]:\n\"\"\"Split first by double-spaced breaks `\\\\n\\\\n` and then by\n    single spaced breaks `\\\\n` to get the position of the segment.\n    Will exclude footnotes and segments with less than 10 characters.\n    For comparison:\n    Minimum characters | Total Num. of Rows | Time to Create from Scratch\n    :--:|:--:|:--:\n    10 | ~3.2m | 30 minutes\n    Args:\n        full_text (str): The opinion to segment\n    Yields:\n        Iterator[dict]: The partial segment data fields\n    \"\"\"\nif cleaned_text := standardize(full_text):\nif subdivisions := double_spaced.split(cleaned_text):\nfor idx, text in enumerate(subdivisions):\nif lines := single_spaced.split(text):\nfor sub_idx, segment in enumerate(lines):\n# --- marks the footnote boundary\nif segment == \"---\":\nreturn\nposition = f\"{idx}-{sub_idx}\"\nchar_count = len(segment)\nif char_count &gt; 10:\nyield {\n\"position\": position,\n\"segment\": segment,\n\"char_count\": char_count,\n}\n</code></pre>"}]}